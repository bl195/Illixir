{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar url = require('url');\n\nvar Task = require('./task');\n\nconst EXPERIENCE_ID_HEADER_NAME = \"X-GOOG-MAPS-EXPERIENCE-ID\";\n\nexports.inject = function (options) {\n  var key = options.key || process.env.GOOGLE_MAPS_API_KEY;\n  var channel = options.channel;\n  var clientId = options.clientId || process.env.GOOGLE_MAPS_API_CLIENT_ID;\n  var clientSecret = options.clientSecret || process.env.GOOGLE_MAPS_API_CLIENT_SECRET;\n  var rate = options.rate || {};\n  var rateLimit = rate.limit || 50; // 50 requests per ratePeriod.\n\n  var ratePeriod = rate.period || 1000; // 1 second.\n\n  var makeUrlRequest = options.makeUrlRequest || require('./make-url-request');\n\n  var mySetTimeout = options.setTimeout || setTimeout;\n  var myClearTimeout = options.clearTimeout || clearTimeout;\n\n  var getTime = options.getTime || function () {\n    return new Date().getTime();\n  };\n\n  var wait = require('./wait').inject(mySetTimeout, myClearTimeout);\n\n  var attempt = require('./attempt').inject(wait).attempt;\n\n  var ThrottledQueue = require('./throttled-queue').inject(wait, getTime);\n\n  var requestQueue = ThrottledQueue.create(rateLimit, ratePeriod);\n  /**\n   * Makes an API request using the injected makeUrlRequest.\n   *\n   * Inserts the API key (or client ID and signature) into the query\n   * parameters. Retries requests when the status code requires it.\n   * Parses the response body as JSON.\n   *\n   * The callback is given either an error or a response. The response\n   * is an object with the following entries:\n   * {\n   *   status: number,\n   *   body: string,\n   *   json: Object\n   * }\n   *\n   * @param {string} path\n   * @param {Object} query This function mutates the query object.\n   * @param {Function} callback\n   * @return {{\n   *   cancel: function(),\n   *   finally: function(function()),\n   *   asPromise: function(): Promise\n   * }}\n   */\n\n  return function (path, query, callback) {\n    callback = callback || function () {};\n\n    var retryOptions = query.retryOptions || options.retryOptions || {};\n    delete query.retryOptions;\n    var timeout = query.timeout || options.timeout || 60 * 1000;\n    delete query.timeout;\n    var useClientId = query.supportsClientId && clientId && clientSecret;\n    delete query.supportsClientId;\n    var queryOptions = query.options || {};\n    delete query.options;\n    var isPost = queryOptions.method === 'POST';\n    var requestUrl = formatRequestUrl(path, isPost ? {} : query, useClientId);\n\n    if (isPost) {\n      queryOptions.body = query;\n    }\n\n    if (options.experienceId) {\n      queryOptions[\"headers\"] = queryOptions[\"headers\"] || {};\n      queryOptions[\"headers\"][EXPERIENCE_ID_HEADER_NAME] = options.experienceId.join(\",\");\n    } // Determines whether a response indicates a retriable error.\n\n\n    var canRetry = queryOptions.canRetry || function (response, query) {\n      return response == null || response.status === 500 || response.status === 503 || response.status === 504 || response.json && (response.json.status === 'OVER_QUERY_LIMIT' || response.json.status === 'RESOURCE_EXHAUSTED' || response.json.status === 'INVALID_REQUEST' && query.pagetoken);\n    };\n\n    delete queryOptions.canRetry; // Determines whether a response indicates success.\n\n    var isSuccessful = queryOptions.isSuccessful || function (response) {\n      return response.status === 200 && (response.json == undefined || response.json.status === undefined || response.json.status === 'OK' || response.json.status === 'ZERO_RESULTS');\n    };\n\n    delete queryOptions.isSuccessful;\n\n    function rateLimitedGet() {\n      return requestQueue.add(function () {\n        return Task.start(function (resolve, reject) {\n          return makeUrlRequest(requestUrl, resolve, reject, queryOptions);\n        });\n      });\n    }\n\n    var timeoutTask = wait(timeout).thenDo(function () {\n      throw 'timeout';\n    });\n    var requestTask = attempt({\n      'do': rateLimitedGet,\n      until: function (response) {\n        return !canRetry(response, query);\n      },\n      interval: retryOptions.interval,\n      increment: retryOptions.increment,\n      jitter: retryOptions.jitter\n    });\n    var task = Task.race([timeoutTask, requestTask]).thenDo(function (response) {\n      // We add the request url and the original query to the response\n      // to be able to use them when debugging errors.\n      response.requestUrl = requestUrl;\n      response.query = query;\n\n      if (isSuccessful(response)) {\n        return Task.withValue(response);\n      } else {\n        return Task.withError(response);\n      }\n    }).thenDo(function (response) {\n      callback(null, response);\n    }, function (err) {\n      callback(err);\n    });\n\n    if (options.Promise) {\n      var originalCallback = callback;\n      var promise = new options.Promise(function (resolve, reject) {\n        callback = function (err, result) {\n          if (err != null) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n\n          originalCallback(err, result);\n        };\n      });\n\n      task.asPromise = function () {\n        return promise;\n      };\n    }\n\n    delete task.thenDo;\n    return task;\n  };\n  /**\n   * Adds auth information to the query, and formats it into a URL.\n   * @param {string} path\n   * @param {Object} query\n   * @param {boolean} useClientId\n   * @return {string} The formatted URL.\n   */\n\n  function formatRequestUrl(path, query, useClientId) {\n    if (channel) {\n      query.channel = channel;\n    }\n\n    if (useClientId) {\n      query.client = clientId;\n    } else if (key && key.indexOf('AIza') == 0) {\n      query.key = key;\n    } else {\n      throw 'Missing either a valid API key, or a client ID and secret';\n    }\n\n    var requestUrl = url.format({\n      pathname: path,\n      query: query\n    }); // When using client ID, generate and append the signature param.\n\n    if (useClientId) {\n      var secret = new Buffer(clientSecret, 'base64');\n      var payload = url.parse(requestUrl).path;\n      var signature = computeSignature(secret, payload);\n      requestUrl += '&signature=' + encodeURIComponent(signature);\n    }\n\n    return requestUrl;\n  }\n  /**\n   * @param {string} secret\n   * @param {string} payload\n   * @return {string}\n   */\n\n\n  function computeSignature(secret, payload) {\n    var signature = new Buffer(require('crypto').createHmac('sha1', secret).update(payload).digest('base64')).toString().replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n    while (signature.length % 4) {\n      signature += '=';\n    }\n\n    return signature;\n  }\n};\n\nexports.EXPERIENCE_ID_HEADER_NAME = EXPERIENCE_ID_HEADER_NAME;","map":{"version":3,"sources":["/Users/brianli/Desktop/covid-19-app/covid-19-app/covid_19_hackathon_app/node_modules/@google/maps/lib/internal/make-api-call.js"],"names":["url","require","Task","EXPERIENCE_ID_HEADER_NAME","exports","inject","options","key","process","env","GOOGLE_MAPS_API_KEY","channel","clientId","GOOGLE_MAPS_API_CLIENT_ID","clientSecret","GOOGLE_MAPS_API_CLIENT_SECRET","rate","rateLimit","limit","ratePeriod","period","makeUrlRequest","mySetTimeout","setTimeout","myClearTimeout","clearTimeout","getTime","Date","wait","attempt","ThrottledQueue","requestQueue","create","path","query","callback","retryOptions","timeout","useClientId","supportsClientId","queryOptions","isPost","method","requestUrl","formatRequestUrl","body","experienceId","join","canRetry","response","status","json","pagetoken","isSuccessful","undefined","rateLimitedGet","add","start","resolve","reject","timeoutTask","thenDo","requestTask","until","interval","increment","jitter","task","race","withValue","withError","err","Promise","originalCallback","promise","result","asPromise","client","indexOf","format","pathname","secret","Buffer","payload","parse","signature","computeSignature","encodeURIComponent","createHmac","update","digest","toString","replace","length"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar url = require('url');\nvar Task = require('./task');\nconst EXPERIENCE_ID_HEADER_NAME = \"X-GOOG-MAPS-EXPERIENCE-ID\";\n\nexports.inject = function(options) {\n\n  var key = options.key || process.env.GOOGLE_MAPS_API_KEY;\n  var channel = options.channel;\n  var clientId = options.clientId || process.env.GOOGLE_MAPS_API_CLIENT_ID;\n  var clientSecret = options.clientSecret || process.env.GOOGLE_MAPS_API_CLIENT_SECRET;\n\n  var rate = options.rate || {};\n  var rateLimit = rate.limit || 50;  // 50 requests per ratePeriod.\n  var ratePeriod = rate.period || 1000;  // 1 second.\n\n  var makeUrlRequest = options.makeUrlRequest || require('./make-url-request');\n  var mySetTimeout = options.setTimeout || setTimeout;\n  var myClearTimeout = options.clearTimeout || clearTimeout;\n  var getTime = options.getTime || function() {return new Date().getTime();};\n  var wait = require('./wait').inject(mySetTimeout, myClearTimeout);\n  var attempt = require('./attempt').inject(wait).attempt;\n  var ThrottledQueue = require('./throttled-queue').inject(wait, getTime);\n  var requestQueue = ThrottledQueue.create(rateLimit, ratePeriod);\n\n  /**\n   * Makes an API request using the injected makeUrlRequest.\n   *\n   * Inserts the API key (or client ID and signature) into the query\n   * parameters. Retries requests when the status code requires it.\n   * Parses the response body as JSON.\n   *\n   * The callback is given either an error or a response. The response\n   * is an object with the following entries:\n   * {\n   *   status: number,\n   *   body: string,\n   *   json: Object\n   * }\n   *\n   * @param {string} path\n   * @param {Object} query This function mutates the query object.\n   * @param {Function} callback\n   * @return {{\n   *   cancel: function(),\n   *   finally: function(function()),\n   *   asPromise: function(): Promise\n   * }}\n   */\n  return function(path, query, callback) {\n\n    callback = callback || function() {};\n\n    var retryOptions = query.retryOptions || options.retryOptions || {};\n    delete query.retryOptions;\n\n    var timeout = query.timeout || options.timeout || 60 * 1000;\n    delete query.timeout;\n\n    var useClientId = query.supportsClientId && clientId && clientSecret;\n    delete query.supportsClientId;\n\n    var queryOptions = query.options || {};\n    delete query.options;\n\n    var isPost = queryOptions.method === 'POST'\n    var requestUrl = formatRequestUrl(path, isPost ? {} : query, useClientId);\n\n    if (isPost) {\n      queryOptions.body = query;\n    }\n\n    if (options.experienceId) {\n      queryOptions[\"headers\"] = queryOptions[\"headers\"] || {};\n      queryOptions[\"headers\"][\n        EXPERIENCE_ID_HEADER_NAME\n      ] = options.experienceId.join(\",\");\n    }\n\n    // Determines whether a response indicates a retriable error.\n    var canRetry = queryOptions.canRetry || function(response, query) {\n      return (\n        response == null\n        || response.status === 500\n        || response.status === 503\n        || response.status === 504\n        || (response.json && (\n            response.json.status === 'OVER_QUERY_LIMIT' ||\n            response.json.status === 'RESOURCE_EXHAUSTED' ||\n            (response.json.status ===  'INVALID_REQUEST'  && query.pagetoken))));\n    };\n    delete queryOptions.canRetry;\n\n    // Determines whether a response indicates success.\n    var isSuccessful = queryOptions.isSuccessful || function(response) {\n      return response.status === 200 && (\n                response.json == undefined ||\n                response.json.status === undefined ||\n                response.json.status === 'OK' ||\n                response.json.status === 'ZERO_RESULTS');\n    };\n    delete queryOptions.isSuccessful;\n\n    function rateLimitedGet() {\n      return requestQueue.add(function() {\n        return Task.start(function(resolve, reject) {\n          return makeUrlRequest(requestUrl, resolve, reject, queryOptions);\n        });\n      });\n    }\n\n    var timeoutTask = wait(timeout).thenDo(function() {\n      throw 'timeout';\n    });\n    var requestTask = attempt({\n      'do': rateLimitedGet,\n      until: function(response) { return !canRetry(response, query); },\n      interval: retryOptions.interval,\n      increment: retryOptions.increment,\n      jitter: retryOptions.jitter\n    });\n\n    var task =\n        Task.race([timeoutTask, requestTask])\n        .thenDo(function(response) {\n          // We add the request url and the original query to the response\n          // to be able to use them when debugging errors.\n          response.requestUrl = requestUrl;\n          response.query = query;\n\n          if (isSuccessful(response)) {\n            return Task.withValue(response);\n          } else {\n            return Task.withError(response);\n          }\n        })\n        .thenDo(\n            function(response) { callback(null, response); },\n            function(err) { callback(err); });\n\n    if (options.Promise) {\n      var originalCallback = callback;\n      var promise = new options.Promise(function(resolve, reject) {\n        callback = function(err, result) {\n          if (err != null) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n          originalCallback(err, result);\n        };\n      });\n      task.asPromise = function() { return promise; };\n    }\n\n    delete task.thenDo;\n    return task;\n  };\n\n  /**\n   * Adds auth information to the query, and formats it into a URL.\n   * @param {string} path\n   * @param {Object} query\n   * @param {boolean} useClientId\n   * @return {string} The formatted URL.\n   */\n  function formatRequestUrl(path, query, useClientId) {\n    if (channel) {\n      query.channel = channel;\n    }\n    if (useClientId) {\n      query.client = clientId;\n    } else if (key && key.indexOf('AIza') == 0) {\n      query.key = key;\n    } else {\n      throw 'Missing either a valid API key, or a client ID and secret';\n    }\n\n    var requestUrl = url.format({pathname: path, query: query});\n\n    // When using client ID, generate and append the signature param.\n    if (useClientId) {\n      var secret = new Buffer(clientSecret, 'base64');\n      var payload = url.parse(requestUrl).path;\n      var signature = computeSignature(secret, payload);\n      requestUrl += '&signature=' + encodeURIComponent(signature);\n    }\n\n    return requestUrl;\n  }\n\n  /**\n   * @param {string} secret\n   * @param {string} payload\n   * @return {string}\n   */\n  function computeSignature(secret, payload) {\n    var signature =\n        new Buffer(\n            require('crypto')\n            .createHmac('sha1', secret)\n            .update(payload)\n            .digest('base64'))\n        .toString()\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+$/, '');\n    while (signature.length % 4) {\n      signature += '=';\n    }\n    return signature;\n  }\n\n};\n\nexports.EXPERIENCE_ID_HEADER_NAME = EXPERIENCE_ID_HEADER_NAME;\n"]},"metadata":{},"sourceType":"script"}