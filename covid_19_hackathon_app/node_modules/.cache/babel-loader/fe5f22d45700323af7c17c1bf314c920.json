{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n;\n/**\n * Polyline encodes an array of LatLng objects.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * @memberof! module:@google/maps\n * @name module:@google/maps.util.encodePath\n * @function\n * @param {LatLng[]} path\n * @return {string}\n */\n\nexports.encodePath = function (path) {\n  var result = [];\n  var start = [0, 0];\n  var end;\n\n  var encodePart = function (part) {\n    part = part < 0 ? ~(part << 1) : part << 1;\n\n    while (part >= 0x20) {\n      result.push(String.fromCharCode((0x20 | part & 0x1f) + 63));\n      part >>= 5;\n    }\n\n    result.push(String.fromCharCode(part + 63));\n  };\n\n  for (var i = 0, I = path.length || 0; i < I; ++i) {\n    end = [Math.round(path[i].lat * 1e5), Math.round(path[i].lng * 1e5)];\n    encodePart(end[0] - start[0]); // lat\n\n    encodePart(end[1] - start[1]); // lng\n\n    start = end;\n  }\n\n  return result.join('');\n};\n/**\n * Decodes a polyline encoded string.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * @memberof! module:@google/maps\n * @name module:@google/maps.util.decodePath\n * @function\n * @param {string} path\n * @return {LatLng[]}\n */\n\n\nexports.decodePath = function (encodedPath) {\n  var len = encodedPath.length || 0;\n  var path = new Array(Math.floor(encodedPath.length / 2));\n  var index = 0;\n  var lat = 0;\n  var lng = 0;\n\n  for (var pointIndex = 0; index < len; ++pointIndex) {\n    var result = 1;\n    var shift = 0;\n    var b;\n\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n\n    lat += result & 1 ? ~(result >> 1) : result >> 1;\n    result = 1;\n    shift = 0;\n\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n\n    lng += result & 1 ? ~(result >> 1) : result >> 1;\n    path[pointIndex] = {\n      lat: lat * 1e-5,\n      lng: lng * 1e-5\n    };\n  }\n\n  path.length = pointIndex;\n  return path;\n};\n\nexports.placesAutoCompleteSessionToken = require('uuid/v4');","map":{"version":3,"sources":["/Users/brianli/Desktop/covid-19-app/covid-19-app/covid_19_hackathon_app/node_modules/@google/maps/lib/util.js"],"names":["exports","encodePath","path","result","start","end","encodePart","part","push","String","fromCharCode","i","I","length","Math","round","lat","lng","join","decodePath","encodedPath","len","Array","floor","index","pointIndex","shift","b","charCodeAt","placesAutoCompleteSessionToken","require"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */;\n\n/**\n * Polyline encodes an array of LatLng objects.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * @memberof! module:@google/maps\n * @name module:@google/maps.util.encodePath\n * @function\n * @param {LatLng[]} path\n * @return {string}\n */\nexports.encodePath = function(path) {\n\n  var result = [];\n  var start = [0, 0];\n  var end;\n\n  var encodePart = function(part) {\n    part = part < 0 ? ~(part << 1) : (part << 1);\n    while (part >= 0x20) {\n      result.push(String.fromCharCode((0x20 | (part & 0x1f)) + 63));\n      part >>= 5;\n    }\n    result.push(String.fromCharCode(part + 63));\n  };\n\n  for (var i = 0, I = path.length || 0; i < I; ++i) {\n    end = [Math.round(path[i].lat * 1e5), Math.round(path[i].lng * 1e5)];\n    encodePart(end[0] - start[0]);  // lat\n    encodePart(end[1] - start[1]);  // lng\n    start = end;\n  }\n\n  return result.join('');\n}\n\n/**\n * Decodes a polyline encoded string.\n *\n * See {@link https://developers.google.com/maps/documentation/utilities/polylinealgorithm}\n *\n * @memberof! module:@google/maps\n * @name module:@google/maps.util.decodePath\n * @function\n * @param {string} path\n * @return {LatLng[]}\n */\nexports.decodePath = function(encodedPath) {\n\n  var len = encodedPath.length || 0;\n  var path = new Array(Math.floor(encodedPath.length / 2));\n  var index = 0;\n  var lat = 0;\n  var lng = 0;\n\n  for (var pointIndex = 0; index < len; ++pointIndex) {\n    var result = 1;\n    var shift = 0;\n    var b;\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n    lat += ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n    result = 1;\n    shift = 0;\n    do {\n      b = encodedPath.charCodeAt(index++) - 63 - 1;\n      result += b << shift;\n      shift += 5;\n    } while (b >= 0x1f);\n    lng += ((result & 1) ? ~(result >> 1) : (result >> 1));\n\n    path[pointIndex] = {lat: lat * 1e-5, lng: lng * 1e-5};\n  }\n  path.length = pointIndex;\n\n  return path;\n};\n\nexports.placesAutoCompleteSessionToken = require('uuid/v4');\n"]},"metadata":{},"sourceType":"script"}