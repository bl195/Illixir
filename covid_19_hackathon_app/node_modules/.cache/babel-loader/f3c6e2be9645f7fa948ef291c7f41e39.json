{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// This is a utility class that makes it easier to work with asynchronous tasks.\n// Here's why I don't just use Promises:\n// (a) I don't want to depend on a Promise implementation.\n// (b) Promises aren't cancellable (yet?), and I want cancellability.\n//\n// This is very stripped down, compared to Promises.\n// (a) You can only call .thenDo() once. Because there's only one party waiting\n//     on the result of a task, cancelling always propagates backwards.\n// (b) The argument to .thenDo() must return either undefined or a Task. I don't\n//     promote values to Tasks, like what happens with Promises.\nvar Task = exports;\n/**\n * Creates a Task.\n *\n * The `doSomething` function is called immediately, so that it can start\n * whatever work is part of this task.\n *\n * The `doSomething` function is given a resolve function and a reject function,\n * and it should call one of them when the task is finished, to report its\n * result.\n *\n * The `doSomething` function can optionally return a cancel function. This will\n * be called if the task is cancelled.\n *\n * @param  {function(function(T), function(?)): function()} doSomething\n * @return {Task<T>}\n * @template T\n */\n\nTask.start = function (doSomething) {\n  var me = {}; // onFinish should be called as soon as both finished and onFinish are\n  // defined. It should be called by the piece of code that just defined either\n  // finished or onFinish.\n\n  var finished;\n  var onFinish;\n  var cleaners = [];\n\n  function finish(err, result) {\n    if (!finished) {\n      finished = {\n        err: err,\n        result: result\n      };\n\n      if (onFinish) {\n        onFinish(); // To prevent memory leaks, delete our reference to onFinish after\n        // calling it.\n\n        onFinish = function () {};\n      }\n\n      var cleanup;\n\n      while (cleanup = cleaners.pop()) {\n        cleanup();\n      }\n\n      if (err === 'cancelled') {\n        if (abort) abort();\n      }\n\n      abort = null;\n    }\n  }\n\n  try {\n    // doSomething must be called immediately.\n    var abort = doSomething(function (result) {\n      finish(null, result);\n    }, function (err) {\n      finish(err, null);\n    });\n  } catch (err) {\n    finish(err, null);\n  }\n  /**\n   * Cancels the task (unless the task has already finished, in which case\n   * this call is ignored).\n   *\n   * Subsequent tasks created with #thenDo will not be started. However, clean-\n   * up code added with #finished will run.\n   */\n\n\n  me.cancel = function () {\n    finish('cancelled', null);\n  };\n  /**\n   * Sets the listener that will be called with the result of this task, when\n   * finished. This function can be called at most once.\n   *\n   * @param {function(?, T)} callback\n   */\n\n\n  function setListener(callback) {\n    if (onFinish) {\n      throw new Error('thenDo/finally called more than once');\n    }\n\n    if (finished) {\n      onFinish = function () {};\n\n      callback(finished.err, finished.result);\n    } else {\n      onFinish = function () {\n        callback(finished.err, finished.result);\n      };\n    }\n  }\n  /**\n   * Creates and returns a composite task, consisting of this task and a\n   * subsequent task.\n   *\n   * @param {function(T): ?Task<U>} onResolve A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the result of this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @param {function(?): ?Task<U>} onReject A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the error produced by this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @return {Task<U>} The composite task. Cancelling the composite task cancels\n   *     either this task or the subsequent task, depending on whether this\n   *     task is finished.\n   * @template U\n   */\n\n\n  me.thenDo = function (onResolve, onReject) {\n    return compose(me, setListener, onResolve, onReject);\n  };\n  /**\n   * Registers a cleanup function, that will be run when the task finishes,\n   * regardless of error or cancellation.\n   *\n   * @param {function()} cleanup\n   * @return {THIS}\n   */\n\n\n  me.finally = function (cleanup) {\n    if (!finished) {\n      cleaners.push(function () {\n        process.nextTick(cleanup);\n      });\n    } else {\n      process.nextTick(cleanup);\n    }\n\n    return me;\n  };\n\n  return me;\n};\n/**\n * Creates a Task with the given result.\n */\n\n\nTask.withValue = function (result) {\n  return Task.start(function (resolve) {\n    resolve(result);\n  });\n};\n/**\n * Creates a Task with the given error.\n */\n\n\nTask.withError = function (err) {\n  return Task.start(function (resolve, reject) {\n    reject(err);\n  });\n};\n/**\n * Returns a new task that races the given tasks. Eventually finishes with the\n * result or error of whichever task finishes first. If any task is cancelled,\n * all of the tasks are cancelled.\n *\n * @param {Array<Task<T>>} tasks\n * @return {Task<T>}\n * @template T\n */\n\n\nTask.race = function (tasks) {\n  return Task.start(function (resolve, reject) {\n    function cancelAll() {\n      tasks.forEach(function (task) {\n        task.cancel();\n      });\n    }\n\n    tasks.forEach(function (task) {\n      task.finally(cancelAll).thenDo(resolve, reject);\n    });\n    return cancelAll;\n  });\n};\n/**\n * Creates a composite task, which uses the output of the first task to create\n * a subsequent task, and represents the two tasks together.\n *\n * This function is internal-only. It is used by Task.thenDo().\n *\n * @param {Task<T>} firstTask\n * @param {function(function(?, T))} whenFirstTaskFinishes The private\n *     setListener method on the firstTask.\n * @param {function(T): Task<U>} onResolve\n * @param {function(?): Task<U>} onReject\n * @return {Task<U>}\n * @template T, U\n */\n\n\nfunction compose(firstTask, whenFirstTaskFinishes, onResolve, onReject) {\n  return Task.start(function (resolve, reject) {\n    var cancelled;\n    var currentTask = firstTask;\n    whenFirstTaskFinishes(function (err, result) {\n      currentTask = null; // createSubsequentTask must be called asynchronously.\n\n      process.nextTick(function () {\n        if (cancelled || err === 'cancelled') {\n          return reject('cancelled');\n        } // Start the subsequent task.\n\n\n        if (err == null) {\n          if (!onResolve) {\n            return resolve(result);\n          }\n\n          try {\n            currentTask = onResolve(result);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } else {\n          if (!onReject) {\n            return reject(err);\n          }\n\n          try {\n            currentTask = onReject(err);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } // Was a subsequent task returned?\n\n\n        if (!currentTask) {\n          return resolve(undefined);\n        }\n\n        currentTask.thenDo(resolve, reject);\n      });\n    });\n    return function cancelCompositeTask() {\n      cancelled = true;\n\n      if (currentTask) {\n        currentTask.cancel();\n      }\n    };\n  });\n}","map":{"version":3,"sources":["/Users/brianli/Desktop/covid-19-app/covid-19-app/covid_19_hackathon_app/node_modules/@google/maps/lib/internal/task.js"],"names":["Task","exports","start","doSomething","me","finished","onFinish","cleaners","finish","err","result","cleanup","pop","abort","cancel","setListener","callback","Error","thenDo","onResolve","onReject","compose","finally","push","process","nextTick","withValue","resolve","withError","reject","race","tasks","cancelAll","forEach","task","firstTask","whenFirstTaskFinishes","cancelled","currentTask","caughtErr","undefined","cancelCompositeTask"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is a utility class that makes it easier to work with asynchronous tasks.\n// Here's why I don't just use Promises:\n// (a) I don't want to depend on a Promise implementation.\n// (b) Promises aren't cancellable (yet?), and I want cancellability.\n//\n// This is very stripped down, compared to Promises.\n// (a) You can only call .thenDo() once. Because there's only one party waiting\n//     on the result of a task, cancelling always propagates backwards.\n// (b) The argument to .thenDo() must return either undefined or a Task. I don't\n//     promote values to Tasks, like what happens with Promises.\n\nvar Task = exports;\n\n/**\n * Creates a Task.\n *\n * The `doSomething` function is called immediately, so that it can start\n * whatever work is part of this task.\n *\n * The `doSomething` function is given a resolve function and a reject function,\n * and it should call one of them when the task is finished, to report its\n * result.\n *\n * The `doSomething` function can optionally return a cancel function. This will\n * be called if the task is cancelled.\n *\n * @param  {function(function(T), function(?)): function()} doSomething\n * @return {Task<T>}\n * @template T\n */\nTask.start = function(doSomething) {\n  var me = {};\n\n  // onFinish should be called as soon as both finished and onFinish are\n  // defined. It should be called by the piece of code that just defined either\n  // finished or onFinish.\n  var finished;\n  var onFinish;\n  var cleaners = [];\n\n  function finish(err, result) {\n    if (!finished) {\n      finished = {err: err, result: result};\n\n      if (onFinish) {\n        onFinish();\n        // To prevent memory leaks, delete our reference to onFinish after\n        // calling it.\n        onFinish = function() {};\n      }\n\n      var cleanup;\n      while (cleanup = cleaners.pop()) {\n        cleanup();\n      }\n\n      if (err === 'cancelled') {\n        if (abort) abort();\n      }\n\n      abort = null;\n    }\n  }\n\n  try {\n    // doSomething must be called immediately.\n    var abort = doSomething(\n        function(result) { finish(null, result); },\n        function(err)    { finish(err,  null);   });\n  } catch (err) {\n    finish(err, null);\n  }\n\n  /**\n   * Cancels the task (unless the task has already finished, in which case\n   * this call is ignored).\n   *\n   * Subsequent tasks created with #thenDo will not be started. However, clean-\n   * up code added with #finished will run.\n   */\n  me.cancel = function() {\n    finish('cancelled', null);\n  };\n\n  /**\n   * Sets the listener that will be called with the result of this task, when\n   * finished. This function can be called at most once.\n   *\n   * @param {function(?, T)} callback\n   */\n  function setListener(callback) {\n    if (onFinish) {\n      throw new Error('thenDo/finally called more than once');\n    }\n    if (finished) {\n      onFinish = function() {};\n      callback(finished.err, finished.result);\n    } else {\n      onFinish = function() {\n        callback(finished.err, finished.result);\n      };\n    }\n  }\n\n  /**\n   * Creates and returns a composite task, consisting of this task and a\n   * subsequent task.\n   *\n   * @param {function(T): ?Task<U>} onResolve A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the result of this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @param {function(?): ?Task<U>} onReject A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the error produced by this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @return {Task<U>} The composite task. Cancelling the composite task cancels\n   *     either this task or the subsequent task, depending on whether this\n   *     task is finished.\n   * @template U\n   */\n  me.thenDo = function(onResolve, onReject) {\n    return compose(me, setListener, onResolve, onReject);\n  };\n\n  /**\n   * Registers a cleanup function, that will be run when the task finishes,\n   * regardless of error or cancellation.\n   *\n   * @param {function()} cleanup\n   * @return {THIS}\n   */\n  me.finally = function(cleanup) {\n    if (!finished) {\n      cleaners.push(function() {\n        process.nextTick(cleanup);\n      });\n    } else {\n      process.nextTick(cleanup);\n    }\n    return me;\n  };\n\n  return me;\n};\n\n/**\n * Creates a Task with the given result.\n */\nTask.withValue = function(result) {\n  return Task.start(function(resolve) {\n    resolve(result);\n  });\n};\n\n/**\n * Creates a Task with the given error.\n */\nTask.withError = function(err) {\n  return Task.start(function(resolve, reject) {\n    reject(err);\n  });\n};\n\n/**\n * Returns a new task that races the given tasks. Eventually finishes with the\n * result or error of whichever task finishes first. If any task is cancelled,\n * all of the tasks are cancelled.\n *\n * @param {Array<Task<T>>} tasks\n * @return {Task<T>}\n * @template T\n */\nTask.race = function(tasks) {\n  return Task.start(function(resolve, reject) {\n    function cancelAll() {\n      tasks.forEach(function(task) {\n        task.cancel();\n      });\n    }\n    tasks.forEach(function(task) {\n      task.finally(cancelAll).thenDo(resolve, reject);\n    });\n    return cancelAll;\n  });\n};\n\n/**\n * Creates a composite task, which uses the output of the first task to create\n * a subsequent task, and represents the two tasks together.\n *\n * This function is internal-only. It is used by Task.thenDo().\n *\n * @param {Task<T>} firstTask\n * @param {function(function(?, T))} whenFirstTaskFinishes The private\n *     setListener method on the firstTask.\n * @param {function(T): Task<U>} onResolve\n * @param {function(?): Task<U>} onReject\n * @return {Task<U>}\n * @template T, U\n */\nfunction compose(firstTask, whenFirstTaskFinishes, onResolve, onReject) {\n  return Task.start(function(resolve, reject) {\n    var cancelled;\n    var currentTask = firstTask;\n\n    whenFirstTaskFinishes(function(err, result) {\n      currentTask = null;\n      // createSubsequentTask must be called asynchronously.\n      process.nextTick(function() {\n        if (cancelled || err === 'cancelled') {\n          return reject('cancelled');\n        }\n\n        // Start the subsequent task.\n        if (err == null) {\n          if (!onResolve) {\n            return resolve(result);\n          }\n          try {\n            currentTask = onResolve(result);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } else {\n          if (!onReject) {\n            return reject(err);\n          }\n          try {\n            currentTask = onReject(err);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        }\n\n        // Was a subsequent task returned?\n        if (!currentTask) {\n          return resolve(undefined);\n        }\n\n        currentTask.thenDo(resolve, reject);\n      });\n    });\n\n    return function cancelCompositeTask() {\n      cancelled = true;\n      if (currentTask) {\n        currentTask.cancel();\n      }\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"script"}